<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<link rel="icon" href="/static/favicon.ico" type="image/x-icon">
<title>Chat LAN</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #fff;
    color: #000;
  }

  #chat {
    border: 1px solid #ccc;
    block-size: 750px;
    overflow-y: auto;
    padding: 10px;
    margin-block-end: 10px;
    white-space: normal;       /* permet le retour automatique √† la ligne */
    word-wrap: break-word;
    overflow-wrap: break-word;
    background-color: #f9f9f9;
    color: #000;
  }
  
  /* Style appliqu√© uniquement aux liens */
  #chat a {
    background-color: #e1e1e1;          /* petit fond blanc */
    padding: 2px 4px;                     /* espace int√©rieur */
    border-radius: 4px;                   /* arrondi l√©ger */
    text-decoration: none;                /* pas de soulignement */
  }

  /* Survol du lien */
  #chat a:hover {
    background-color: rgba(0, 0, 0, 0.9);
  }

  .message {                   /* classe √† appliquer √† chaque message */
    display: block;      /* chaque message occupe toute la largeur disponible */
    max-inline-size: 700px;           /* largeur maximale du message */
    word-wrap: break-word;
    overflow-wrap: break-word;
    white-space: pre-wrap;   /* conserve les retours √† la ligne et permet le wrapping */
    word-break: break-all;   /* coupe absolument les cha√Ænes trop longues */
    padding: 5px 10px;
    border-radius: 5px;
    margin-block-end: 5px;
  }

/* Appliquer un style bulle uniquement pour le texte */
  .message .bubble {
    display: inline-block;
    max-inline-size: 80%;
    padding: 10px 14px;
    border-radius: 8px;
    background-color: #e1e1e1;
    color: #000;
    word-wrap: break-word;
    white-space: pre-wrap;
  }

  .message a {
  display: inline-block; /* le lien ne prend que la taille de son contenu */
  max-inline-size: fit-content; 
  }
/* Fond noir pour les lecteurs audio en mode clair */
  audio {
    background-color: #000;
    border-radius: 6px;
    padding: 4px;
  }

  textarea, input, button {
    font-family: inherit;
    font-size: 14px;
    color: inherit;
    background-color: #fff;
   }

  /* Dark mode */
  @media (prefers-color-scheme: dark) {
    body {
      background-color: #121212;
      color: #e0e0e0;
    }

    #chat {
      border-color: #444;
      background-color: #1e1e1e;
      color: #e0e0e0;
    }

    .message {
      
      color: #e0e0e0;
    }
    .message .bubble {
        background-color: #2c2c2c;
        color: #e0e0e0;
    }
    audio {
    background-color: #1e1e1e;
    }
    textarea, input, button {
      background-color: #2c2c2c;
      color: #e0e0e0;
      border: 1px solid #555;
    }
  }
</style>
</head>
<body>

<div id="chat"></div>

<textarea id="message" placeholder="Tape ton message..." rows="3" style="inline-size:70%;"></textarea>
<button id="sendBtn">Envoyer</button>
<input type="file" id="fileInput" multiple />
<button id="fileBtn">Uploader</button>
<button id="recordBtn">üéôÔ∏è Enregistrer</button>

<script>
const chat = document.getElementById("chat");
const input = document.getElementById("message");
const fileInput = document.getElementById("fileInput");

// R√©cup√®re ou cr√©e un identifiant unique qui reste en m√©moire
let clientId = localStorage.getItem("clientId");
if (!clientId) {
    clientId = Math.random().toString(36).substring(2, 15);
    localStorage.setItem("clientId", clientId);
}

// ‚ö†Ô∏è IP de ton serveur
const SERVER_URL = "http://127.0.0.1:5000/";
const ws = new WebSocket("ws://127.0.0.1:5000/ws");

// Fonction pour afficher un message
function appendMessage(sender, text, isFile=false) {
    const msg = document.createElement("div");
    msg.classList.add("message");
    msg.classList.add(sender === "Moi" ? "me" : "other");

    if (isFile) {
        const ext = text.split('.').pop().toLowerCase();

        // üîπ On ajoute un label "Moi:" ou "Autre:"
        const label = document.createElement("div");
        label.textContent = sender + ":";
        label.style.fontWeight = "bold";
        label.style.marginBottom = "4px";
        msg.appendChild(label);

        if (["png", "jpg", "jpeg", "gif", "webp"].includes(ext)) {
            // üì∑ Image
            const a = document.createElement("a");
            a.href = text;
            a.target = "_blank";

            const img = document.createElement("img");
            img.src = text;
            img.style.maxWidth = "320px";
            img.style.maxHeight = "260px";
            img.style.display = "block";
            img.style.borderRadius = "8px";

            a.appendChild(img);
            msg.appendChild(a);

        } else if (["mp4", "webm", "ogg"].includes(ext)) {
            // üé• Vid√©o
            const video = document.createElement("video");
            video.src = text;
            video.controls = true;
            video.style.maxWidth = "360px";
            video.style.maxHeight = "260px";
            video.style.display = "block";
            video.style.borderRadius = "8px";

            msg.appendChild(video);

        } else if (["mp3", "wav", "ogg"].includes(ext)) {
            // üéµ Audio
            const audio = document.createElement("audio");
            audio.src = text;
            audio.controls = true;
            audio.style.width = "320px";
            audio.style.display = "block";

            msg.appendChild(audio);

        } else {

            // üìé Autres fichiers (EXE avec ic√¥ne)
            const a = document.createElement("a");
            a.href = text;
            a.target = "_blank";
            a.style.display = "flex";
            a.style.alignItems = "center";
            a.style.gap = "6px";

            const filename = text.split("/").pop();
            const ext = filename.split('.').pop().toLowerCase();

            let iconSrc;

            // Gestion des EXE
            if (ext === "exe") {
                iconSrc = "/static/icons/exe-icon.png";  // ic√¥ne g√©n√©rique pour EXE
            } else {
                iconSrc = "/static/icons/file-icon.png"; // ic√¥ne g√©n√©rique pour les autres fichiers
            }

            const icon = document.createElement("img");
            icon.src = iconSrc;
            icon.style.width = "24px";
            icon.style.height = "24px";

            const label = document.createElement("span");
            label.textContent = filename;

            a.appendChild(icon);
            a.appendChild(label);
            msg.appendChild(a);

        }

    } else {
        // Texte avec lien cliquable
        const bubble = document.createElement("div");
        bubble.classList.add("bubble");
        bubble.innerHTML = sender + ": " + text
            .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>')
            .replace(/\n/g, "<br>");

        msg.appendChild(bubble);
    }

    chat.appendChild(msg);
    chat.scrollTop = chat.scrollHeight;
}
let mediaRecorder;
let audioChunks = [];

document.getElementById("recordBtn").addEventListener("click", async () => {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Impossible d‚Äôacc√©der au micro : votre navigateur ou la page ne supporte pas getUserMedia (HTTPS requis).");
        return;
    }

    try {
        if (!mediaRecorder || mediaRecorder.state === "inactive") {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: "audio/mp3" });
                const file = new File([audioBlob], `voice_${Date.now()}.mp3`, { type: "audio/mp3" });

                const formData = new FormData();
                formData.append("files", file);

                const res = await fetch(`${SERVER_URL}/upload/`, { method: "POST", body: formData });
                const data = await res.json();

                for (const filename of data.filenames) {
                    const fileUrl = `${SERVER_URL}/files/` + filename;
                    appendMessage("Moi", fileUrl, true);
                    ws.send(JSON.stringify({ clientId: clientId, text: fileUrl, isFile: true }));
                }
            };

            mediaRecorder.start();
            document.getElementById("recordBtn").textContent = "‚èπÔ∏è Arr√™ter";
        } else if (mediaRecorder.state === "recording") {
            mediaRecorder.stop();
            document.getElementById("recordBtn").textContent = "üéôÔ∏è Enregistrer";
        }
    } catch (err) {
        alert("Erreur lors de l'acc√®s au micro : " + err.message);
        console.error(err);
    }
});

// üîπ Charger l'historique depuis le serveur
async function loadHistory() {
    try {
        const res = await fetch(`${SERVER_URL}/history`);
        const history = await res.json();
        history.forEach(msg => {
            if (msg.clientId === clientId) {
                appendMessage("Moi", msg.text, msg.isFile);
            } else {
                appendMessage("Autre", msg.text, msg.isFile);
            }
        });
    } catch (err) {
        console.error("Erreur de chargement de l‚Äôhistorique :", err);
    }
}

// Appeler d√®s le chargement
loadHistory();

// Historique des messages envoy√©s (max 5)
let messageHistory = JSON.parse(localStorage.getItem("messageHistory") || "[]");
let historyIndex = -1; // position actuelle dans l‚Äôhistorique
function saveMessageHistory() {
    localStorage.setItem("messageHistory", JSON.stringify(messageHistory));
}

// Envoi message texte
function sendMessage(keepText = false) {
    const text = input.value.trim();
    if (!text) return;

    appendMessage("Moi", text);
    ws.send(JSON.stringify({ clientId: clientId, text: text }));

    messageHistory.unshift(text); // ‚Üê Ajout du message ici !
    // ‚úÖ On stocke le message dans l‚Äôhistorique (max 5)
    if (messageHistory.length > 5) messageHistory.pop();
    saveMessageHistory();

    historyIndex = -1; // reset navigation
    if (!keepText) input.value = "";
}


// Gestion des touches clavier
input.addEventListener("keydown", function(event) {
    if (event.key === "Enter") {
        if (event.shiftKey) {
            // Shift+Enter ‚Üí saut de ligne
            const start = input.selectionStart;
            const end = input.selectionEnd;
            input.value = input.value.substring(0, start) + "\n" + input.value.substring(end);
            input.selectionStart = input.selectionEnd = start + 1;
            event.preventDefault();
        } else if (event.ctrlKey) {
            // Ctrl+Enter ‚Üí envoyer mais garder le texte
            event.preventDefault();
            sendMessage(true);
        } else {
            // Enter seul ‚Üí envoyer et vider le champ
            event.preventDefault();
            sendMessage(false);
        }
    } 
    
    else if (event.key === "ArrowUp") {
        // ‚Üë ‚Üí message pr√©c√©dent
        if (messageHistory.length > 0) {
            if (historyIndex < messageHistory.length - 1) {
                historyIndex++;
                input.value = messageHistory[historyIndex];
            }
        }
        event.preventDefault()
    } 
    
    else if (event.key === "ArrowDown") {
        // ‚Üì ‚Üí message suivant ou champ vide
        if (historyIndex > 0) {
            historyIndex--;
            input.value = messageHistory[historyIndex];
        } else {
            historyIndex = -1;
            input.value = "";
        }
        event.preventDefault();
    }
});


// Gestion collage d'images/GIFs depuis le presse-papier
input.addEventListener("paste", async (event) => {
    const clipboardItems = event.clipboardData.items;

    for (let i = 0; i < clipboardItems.length; i++) {
        const item = clipboardItems[i];

        if (item.kind === "file" && item.type.startsWith("image/")) {
            const file = item.getAsFile();
            const formData = new FormData();
            formData.append("files", file);

            try {
                const res = await fetch(`${SERVER_URL}/upload/`, {
                    method: "POST",
                    body: formData
                });

                const data = await res.json();

                for (const filename of data.filenames) {
                    const fileUrl = `${SERVER_URL}/files/${filename}`;
                    appendMessage("Moi", fileUrl, true);
                    ws.send(JSON.stringify({ clientId: clientId, text: fileUrl, isFile: true }));
                }
            } catch (err) {
                console.error("Erreur upload GIF :", err);
            }

            event.preventDefault();
        }
    }
});

// Bouton envoyer
document.getElementById("sendBtn").addEventListener("click", sendMessage);

// Upload fichiers
async function uploadFile() {
    if (!fileInput.files.length) return;

    const formData = new FormData();

    // Parcourt tous les fichiers s√©lectionn√©s
    for (const file of fileInput.files) {
        formData.append("files", file); // le nom "files" doit correspondre au backend
    }

    const res = await fetch(`${SERVER_URL}/upload/`, { 
        method: "POST", 
        body: formData 
    });
    const data = await res.json();

    // Envoie un message WebSocket pour chaque fichier
    for (const filename of data.filenames) {
        const fileUrl = `${SERVER_URL}/files/` + filename;
        appendMessage("Moi", fileUrl, true);
        ws.send(JSON.stringify({ clientId: clientId, text: fileUrl, isFile: true }));
    }
    // R√©initialise l'input
    fileInput.value = "";
}
document.getElementById("fileBtn").addEventListener("click", uploadFile);

// Messages WebSocket
ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.clientId === clientId) return;

    appendMessage("Autre", data.text, data.isFile);
};
</script>

</body>
</html>